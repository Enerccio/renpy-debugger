#!/bin/python

import json
import re

from io import StringIO
from collections import OrderedDict


class Property(object):
    def __init__(self, name, type):
        self.name = name
        self.type = type
        self.enum = None

        self.default = None
        self.ref = None
        self.desc = "None"

        self.subproperty = False
        self.property = StringIO()


class Superclass(object):
    def __init__(self, name):
        self.name = name
        self.named = []
        self.optional = []
        self.optional_values = {}
        self.additional_properties = False
        self.constargs = {}
        self.determinate = None
        self.parent = None


def to_snake(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def generate(path):
    with open("debugAdapterProtocol.json", "r") as schema_file:
        schema = json.load(schema_file, object_hook=OrderedDict)
        t = StringIO()
        all = set()
        supers = {}

        print("# THIS FILE IS AUTOGENERATED, DO NOT MODIFY!", file=t)
        print("", file=t)
        print("# py23 compatible", file=t)
        print("from __future__ import print_function", file=t)
        print("from __future__ import division", file=t)
        print("from __future__ import unicode_literals", file=t)
        print("from __future__ import absolute_import", file=t)
        print("", file=t)
        print("from .base import DAPMessage, DAPObject", file=t)
        print("", file=t)
        print("__undefined__ = object()", file=t)

        dapmessage = Superclass("DAPMessage")
        dapmessage.determinate = []
        supers["DAPMessage"] = dapmessage

        for definition_name in schema["definitions"]:
            definition = schema["definitions"][definition_name]

            name = "DAP" + definition_name
            base_class = "DAPMessage" if definition_name == "ProtocolMessage" else "DAPObject"
            description = definition["description"] if "description" in definition else ""

            if "allOf" in definition.keys():
                base_class_ref = definition["allOf"][0]["$ref"]
                base_class = "DAP" + base_class_ref[base_class_ref.rfind("/") + 1:]
                definition = definition["allOf"][1]

            generate_object(t, name, base_class, description, definition, supers, all)

        leafs = set()
        for cls_name in supers:
            cls = supers[cls_name]
            leafs.add(cls)
            if cls.parent is not None and cls.parent in leafs:
                if cls.determinate == cls.parent.determinate:
                    leafs.remove(cls)
                else:
                    leafs.remove(cls.parent)

        leafs = sorted(list(leafs), key=lambda x: x.name)

        print("", file=t)
        print("", file=t)
        print("def _determine_root_factory(data):", file=t)
        for cls in leafs:
            if cls.determinate is not None:
                conditions = []
                for d in cls.determinate:
                    conditions.append("data[\"%s\"] == %s" % d)
                print("    if %s:" % " and ".join(conditions), file=t)
                print("        return %s" % cls.name, file=t)
        print("    raise ValueError(\"unknown entity to factory binding \" + str(data))", file=t)

        print("", file=t)
        print("", file=t)
        print("DAPObject.determine_root_factory = _determine_root_factory", file=t)

        print("", file=t)
        print("", file=t)
        print("__all__ = %s" % str(list(all)), file=t)

        with open(path, "wb") as res:
            res.write(t.getvalue().encode("utf-8"))


def generate_object(t, name, base_class, description, definition, supers, all):
    all.add(name)

    required = []
    if "required" in definition:
        required = definition["required"]

    properties = []

    if "properties" in definition:
        for property_name in definition["properties"]:
            prop = definition["properties"][property_name]
            p = Property(property_name, prop["type"] if type in prop else None)

            properties.append(p)

            if "description" in prop:
                p.desc = prop["description"]

            if "$ref" not in prop:
                if prop["type"] == "object":
                    p.subproperty = True
                    p.ref = name + property_name.capitalize()
                    generate_object(p.property, p.ref,
                                    "DAPObject", p.desc, prop, supers, all)
            else:
                ref = prop["$ref"]
                p.ref = "DAP" + ref[ref.rfind("/") + 1:]

            if "enum" in prop:
                p.enum = "\"%s\"" % prop["enum"][0]


    print("", file=t)
    print("", file=t)
    print("class %s(%s):" % (name, base_class), file=t)
    print("    \"\"\"", file=t)
    print("    %s" % description, file=t)
    print("    \"\"\"", file=t)

    arguments = []
    superargs = ["self"]
    override = set()

    supercls = supers[base_class] if base_class in supers else None
    me = Superclass(name)
    me.parent = supercls
    supers[name] = me
    used_args = set()

    full_list_seq = []
    full_list_seq_pm = []
    only_new_args = []

    # determinator
    if supercls is not None and supercls.determinate is not None:
        me.determinate = supercls.determinate + []
        for p in properties:
            if p.enum is not None:
                me.determinate.append((p.name, p.enum))


    if supercls is not None:
        for sarg in supercls.named:
            arguments.append(to_snake(sarg))
            me.named.append(sarg)
            superargs.append(to_snake(sarg))
            if sarg in supercls.constargs:
                full_list_seq.append(supercls.constargs[sarg])
                me.constargs[sarg] = supercls.constargs[sarg]
            else:
                found = False
                for p in properties:
                    if p.name in required and p.name == sarg and p.enum is not None:
                        found = True
                        full_list_seq.append(p.enum)
                        break

                if not found:
                    full_list_seq.append(to_snake(sarg))
                    only_new_args.append(to_snake(sarg))

    for p in properties:
        if p.name in required and (supercls is None or p.name not in supercls.named):
            if supercls is not None and p.name in supercls.optional:
                arguments.append(to_snake(p.name))
                me.named.append(p.name)
                used_args.add(p)

                only_new_args.append(to_snake(p.name))
                full_list_seq_pm.append(to_snake(p.name) + "=" + to_snake(p.name))
            else:
                arguments.append(to_snake(p.name))
                me.named.append(p.name)
                used_args.add(p)

                full_list_seq.append(to_snake(p.name))
                only_new_args.append(to_snake(p.name))
                if p.enum is not None:
                    me.constargs[p.name] = p.enum
        elif supercls is not None:
            override.add(p.name)

    full_list_seq += full_list_seq_pm

    if supercls is not None:
        for sarg in supercls.optional:
            if sarg not in [x.name for x in used_args]:
                arguments.append(to_snake(sarg) + "=" + supercls.optional_values[sarg])
                me.optional.append(sarg)
                me.optional_values[sarg] = supercls.optional_values[sarg]
                superargs.append(to_snake(sarg))

                full_list_seq.append(to_snake(sarg) + "=" + to_snake(sarg))
                only_new_args.append(to_snake(sarg) + "=" + supercls.optional_values[sarg])
            else:
                superargs.append(to_snake(sarg) + "=" + to_snake(sarg))

    for p in properties:
        if p.name not in required and (supercls is None or p.name not in supercls.optional):
            arguments.append(to_snake(p.name) + "=" + (p.default if p.default is not None else "__undefined__"))
            me.optional.append(p.name)
            used_args.add(p)
            me.optional_values[p.name] = p.default if p.default is not None else "__undefined__"

            full_list_seq.append(to_snake(p.name) + "=" + to_snake(p.name))
            only_new_args.append(to_snake(p.name) + "=" + (p.default if p.default is not None else "__undefined__"))
        elif supercls is not None:
            override.add(p.name)


    if "additionalProperties" in definition or (supercls is not None and supercls.additional_properties):
        if supercls is not None and supercls.additional_properties:
            superargs.append("**kwargs")

        arguments.append("**kwargs")
        full_list_seq.append("**kwargs")
        only_new_args.append("**kwargs")
        me.additional_properties = True

    print("    @staticmethod", file=t)
    print("    def create(%s):" % ", ".join(only_new_args), file=t)
    print("        return %s(%s)" % (name, ", ".join(full_list_seq)), file=t)
    print("    ", file=t)

    if len(arguments) == 0:
        print("    def __init__(self):", file=t)
    else:
        print("    def __init__(self, %s):" % ", ".join(arguments), file=t)

    if supercls is not None:
        print("        %s.__init__(%s)" % (supercls.name, ", ".join(superargs)), file=t)
    else:
        print("        DAPObject.__init__(self)", file=t)

    for p in properties:
        if p in used_args:
            print("        self.%s = %s" % (p.name, to_snake(p.name)), file=t)

    if "additionalProperties" in definition:
        print("        self.additionalProperties = kwargs", file=t)

    for p in properties:
        if p in used_args:
            print("    ", file=t)
            if p.name in required:
                print("    def get_%s(self):" % to_snake(p.name), file=t)
                print("        return self.%s" % p.name, file=t)
                print("    ", file=t)
                print("    def set_%s(self, %s):" % (to_snake(p.name), to_snake(p.name)), file=t)
                print("        self.%s = %s" % (p.name, to_snake(p.name)), file=t)
                print("        return self", file=t)
            else:
                print("    def get_%s(self):" % to_snake(p.name), file=t)
                print("        if self.%s is __undefined__:" % p.name, file=t)
                print("            raise ValueError(\"%s is not defined\")" % p.name, file=t)
                print("        return self.%s" % p.name, file=t)
                print("    ", file=t)
                print("    def has_%s(self):" % to_snake(p.name), file=t)
                print("        return self.%s is not __undefined__" % p.name, file=t)
                print("    ", file=t)
                print("    def set_%s(self, %s):" % (to_snake(p.name), to_snake(p.name)), file=t)
                print("        self.%s = %s" % (p.name, to_snake(p.name)), file=t)
                print("        return self", file=t)
                print("    ", file=t)
                print("    def clear_%s(self):" % to_snake(p.name), file=t)
                print("        self.%s = __undefined__" % p.name, file=t)
                print("        return self", file=t)

    print("    ", file=t)
    print("    def _serialize(self, me, override):", file=t)
    print("        %s._serialize(self, me, %s)" % (base_class, repr(sorted(list(override)))), file=t)
    print("        ", file=t)

    for p in properties:

        print("        # property: %s" % p.name, file=t)
        print("        if \"%s\" not in override:" % p.name, file=t)
        if p.ref is None:
            if p.name not in required:
                print("            if self.%s is not __undefined__:" % p.name, file=t)
                print("                me[\"%s\"] = self.serialize_scalar(me, \"%s\", self.%s)" % (p.name, p.name, p.name), file=t)
            else:
                print("            me[\"%s\"] = self.serialize_scalar(me, \"%s\", self.%s)" % (p.name, p.name, p.name), file=t)
        else:
            if p.name not in required:
                print("            if self.%s is not __undefined__:" % p.name, file=t)
                print("                me[\"%s\"] = self.%s.serialize()" % (p.name, p.name), file=t)
            else:
                print("            me[\"%s\"] = self.%s.serialize()" % (p.name, p.name), file=t)

    if me.additional_properties:
        print("        # additionalProperties", file=t)
        print("        for key in self.kwargs:", file=t)
        print("            self.serialize_scalar(me, key, self.kwargs[key])", file=t)


    print("    ", file=t)
    print("    @classmethod", file=t)
    print("    def _deserialize(cls, args, kwargs, used_args, me, override):", file=t)
    print("        %s._deserialize(args, kwargs, used_args, me, %s)" % (base_class, repr(list(sorted(override)))), file=t)
    print("        ", file=t)

    for p in properties:

        print("        # property: %s" % p.name, file=t)
        print("        if \"%s\" not in override:" % p.name, file=t)
        print("            used_args.append(\"%s\")" % p.name, file=t)
        if p.ref is None:
            if p.name not in required:
                print("            if \"%s\" in me:" % p.name, file=t)
                print("                kwargs[\"%s\"] = cls.deserialize_scalar(me[\"%s\"])" % (p.name, p.name), file=t)
            else:
                print("            args.append(cls.deserialize_scalar(me[\"%s\"]))" % p.name, file=t)
        else:
            if p.name not in required:
                print("            if self.%s is not __undefined__:" % p.name, file=t)
                print("                kwargs[\"%s\"] = cls.deserialize_as(me[\"%s\"], %s)" % (p.name, p.name, p.ref), file=t)
            else:
                print("            args.append(cls.deserialize_as(me[\"%s\"], %s))" % (p.name, p.ref), file=t)

    if me.additional_properties:
        print("        # additionalProperties", file=t)
        print("        for key in me:", file=t)
        print("            if key not in used_args:", file=t)
        print("                kwargs[key] = cls.deserialize_scalar(me[key])", file=t)


    for p in properties:
        if p.subproperty:
            print("%s" % p.property.getvalue(), file=t)


if __name__ == "__main__":
    generate("../librpydb/protocol/gen.py")
